describe.only('Cache', function() {
	beforeEach(angular.mock.module('Checkbook'));

	var Cache;
	beforeEach(inject(function(_Cache_) {
		Cache = _Cache_;
	}));

	describe('.put', function() {
		it('should contain the added item', function() {
			const KEY = 'key';
			var cache = new Cache();
			var item = {};

			cache.put(KEY, item);

			expect(cache.items[KEY]).to.equal(item);
		});

		it('should autogenerate a key using the key function', function() {
			const KEY = 'autogenerated';
			var keyFn = sinon.stub().returns(KEY);
			var cache = new Cache({ elem: keyFn, coll: keyFn });
			var x = {};

			cache.put(x);
			expect(keyFn).to.have.been.called;
			expect(cache.items[KEY]).to.equal(x);

			x = [];
			cache.put(x);
			expect(keyFn).to.have.been.calledTwice;
			expect(cache.items[KEY]).to.equal(x);
		});

		it('should add all elements of a collection', function() {
			var keygen = {
				elem: function(x) { return '/' + x.id },
				coll: function(x) { return '/' }
			};
			var cache = new Cache(keygen);
			var coll = [ { id: 1 }, { id: 2} ];

			cache.put(coll);
			expect(cache.items[keygen.coll(coll)]).to.equal(coll);
			for (var i = 0; i < coll.length; i++) 
				expect(cache.items[keygen.elem(coll[i])]).to.equal(coll[i]);			
		});
	});

	describe('.remove', function() {
		it('should not contain an item after it has been removed', function() {
			const KEY = 'key';
			var cache = new Cache();
			var item = {};

			cache.items[KEY] = item;
			cache.remove(KEY);

			expect(cache.items[KEY]).to.not.exist;
		})
	})
});