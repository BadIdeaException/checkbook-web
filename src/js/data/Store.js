// Steps:
// 1. Inserting a collection also inserts the elements in that collection
// 2. Inserting an element also inserts it into its collection, if it is present
// 3. Updating an element moves it from one collection to the other
// 4. Deleting an element deletes it from its collection

// I need the ability to translate an element key to a collection key
// I need the ability to make element keys for elements in a collection
angular
	.module('Checkbook.Data')
	/**
	 * @ngdoc service
	 * @name  Store
	 * @description 
	 * A data store for RESTful resources. These can be put into, retrieved from and deleted from the store under an identifying key. 
	 * 
	 * Individual resources (called _elements_) are usually part of a _collection_. For instance, in a hypothetical RESTful architecture, 
	 * individual `User` resources (elements) might be available under `/api/users/1`, while `/api/users` gives a list
	 * of all users (the associated collection). The store automatically manages this element-collection relationship. 
	 * This means that
	 * 1. when an element is added to the store, and the store contains the associated collection, the element will be included
	 * into the collection
	 * 2. when a collection is added to the store, all the elements it contains will also be added
	 * 3. when an element is removed from the store, and the store contains the associated collection, the element will also be
	 * removed from the collection.
	 * 4. when a collection is removed from the store, however, its elements will *not* be removed.
	 *
	 * 
	 */
	.factory('Store', function() {
		// Terminology:
		// An element is a basic thing that can be contained in the store (for example an object)
		// A collection can be contained in the store. It consists of elements (for example an array of objects)
		// An item can be either an element or a collection
		var isCollection = angular.isArray;

		/*
		 * @ngdoc function		 
		 * @constructs Store
		 * Creates a new Store. The `keygen` must be an object containing two methods:
		 * - `elem` must return a key for an element when passed an element
		 * - `coll` must return a key for a collection when passed a collection, and a key for the collection that should
		 * contain the element when passed an element
		 * @param {Object} keygen Key generator to use. It must have methods `elem` and `coll`.
		 * @throws {TypeError} If `keygen` isn't an object with methods `elem` and `coll`
		 */
		function Store(keygen) {
			var self = this;
			if (!keygen)
				throw new TypeError('No keygen provided');
			else if (typeof keygen.elem !== 'function' || typeof keygen.coll !== 'function')
				throw new TypeError('keygen must have methods elem and coll');

			self.items = {};

			self.keygen = keygen;
		}

		/**
		 * @ngdoc method
		 * @methodOf Store
		 * @name  put
		 * @description
		 * Puts an item into the store. If the item is an element, and the element's associated collection is
		 * present in the store (as determined by calling `keygen.coll`), the element will be appended to that
		 * collection. If the item is a collection, all elements in the collection are put into the store as well.
		 * @param {String} [key]  The key to store the item under. If provided, this will override the key generated by the 
		 * key generator. Note that providing a key is not recommended and may break the element-collection relationship.
		 * @param  {Object} item The item to store.
		 */
		Store.prototype.put = function(key, item) {
			var self = this;

			if (!item) { // No key was passed
				item = key; 
				key = isCollection(item) ? self.keygen.coll(item) : self.keygen.elem(item);
			}

			if (typeof item !== 'object') throw new TypeError('Item was not an object: ' + typeof item + ' ' + item);

			self.items[key] = item;
			
			// If adding a collection, add all elements of that collection as well
			if (isCollection(item)) {
				item.forEach(function(item) { self.items[self.keygen.elem(item)] = item; });
			}

			// If we add an element, and there is a collection that this element
			// should be contained in, add it to the collection as well
			if (!isCollection(item) && self.has(self.keygen.coll(item))) {
				var coll = self.get(self.keygen.coll(item));
				if (coll.indexOf(item) === -1) // THIS WILL ONLY WORK IF ITEMS ARE OBJECTS
					coll.push(item);
			}
		}

		/**
		 * @ngdoc method
		 * @methodOf Store
		 * @name  Store#get
		 * @description
		 * Retrieves an item from the store.
		 * @param  {String} key The key for which to retrieve the item.
		 * @return {Object} The item contained in the store for that key, or `undefined` if no such item exists.
		 */
		Store.prototype.get = function(key) {
			var self = this;
			return self.items[key];
		};

		/**
		 * @ngdoc method
		 * @methodOf Store
		 * @name  remove
		 * @description
		 * Removes an item from the store. If the item is an element, and its associated collection is
		 * also contained in the store, it is removed from the collection. If the item is a collection,
		 * **only** the collection is removed - its contained elements are kept in the store.
		 * @param  {String} key The key of the item to remove.
		 */
		Store.prototype.remove = function(key) {
			var self = this;
			var item = self.items[key];
			delete self.items[key];

			if (!isCollection(item) && self.has(self.keygen.coll(item))) {
				var coll = self.get(self.keygen.coll(item));
				if (coll.indexOf(item) > -1) // This should always be the case
					coll.splice(coll.indexOf(item), 1);
			}
		};

		/**
		 * @ngdoc method
		 * @methodOf Store
		 * @name  has
		 * @description Checks if an item for the given key is currently contained in the store.
		 * @param  {String}  key The key for which to check
		 * @return {Boolean}     Whether or not the item is contained in the store.
		 */
		Store.prototype.has = function(key) {
			var self = this;
			return self.items[key] !== undefined;
		};

		return Store;
	});